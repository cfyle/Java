/*
 * 
 *  1. 정상적인 명령 흐름을 방해하는 이벤트를 '예외' 라고 부릅니다
 *  	1-1. 이 때 예외 처리가 없는 경우, 프로그램은 어떻게 되나요?
 *  	- 컴파일 오류
 * 		1-2. 발생한 예외를 '잡는' 방법은?
 * 		- try, catch 문을 이용해서 예외상황을 넘긴다
 * 		1-3. 메소드가 호출된 순서의 역순을 무엇이라고 부르나요?
 * 		- callStack
 * 
 *  2. 예외를 활용했을 때의 장점?
 *  	2-1. 상위 호출 스택으로 예외 정보를 전파할 수 있다
 *  	2-2. Type의 이름과 message 필드로 구체적 정보를 전달할 수 있다
 *  	2-3. 계층 구조를 활용한 동작 처리가 가능하다.
 *  	2-4. checked 예외를 발생시키면, 예외처리를 강제할 수 있다,
 * 
 *  3. 예외 객체의 최상위 클래스의 명칭?
 *  	3-1. checked, unchecked 예외를 분류하는 기준?
 *  	- object <- throwable <- Exception
 *  	3-2. 메소드 내에서 발생한 checked 예외를 명시적으로 상위 호출스택으로 전달하는 법?
 * 		- throws 이용
 *  4. try 블럭을 조합해, 언제나 실행을 보장받는 block을 구성하는 방법은?
 *  - finally
 * 
 *  5. 여러 개의 catch 블럭을 구성할 때, 순서는?
 *  
 *  6. 발생한 예외객체의 printCallStackTrace 메소드를 호출해 보세요
 */
public class Q {
}
